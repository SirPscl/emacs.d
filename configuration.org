#+TITLE: Emacs configuration

* Dependencies

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(
                         ("gnu" . "https://elpa.gnu.org/packages/")
                         ("marmalade" . "https://marmalade-repo.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")))
(package-initialize)

(defvar my-packages '(
                      ac-math
                      auctex
                      auto-complete
                      calfw
                      dictcc
                      dictionary
                      drag-stuff
                      elfeed
                      elfeed-org
                      elfeed-goodies
                      elpy
                      emojify
                      evil
                      evil-ediff
                      evil-god-state
                      evil-leader
                      evil-mu4e
                      evil-org
                      fill-column-indicator
                      fixme-mode
                      fsharp-mode
                      helm-projectile
                      js2-mode
                      lua-mode
                      magit
                      markdown-mode
                      mu4e-alert
                      mu4e-maildirs-extension
                      neotree
                      openwith
                      powerline
                      projectile
                      rainbow-delimiters
                      ruby-electric
                      smex
                      tern
                      tern-auto-complete))

(defvar old-packages '(ess
                       linum
                       move-text
                       multi-term
                       shell-command
                       smart-mode-line
                       zenburn-theme))

(dolist (p my-packages)
  (unless (package-installed-p p)
    (package-install p)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
#+END_SRC

* Setup
** Gemeral Setup
*** Menu, Toolbar and Splashscreen

No fancy stuff for me.

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t)
(menu-bar-mode -1)
(tool-bar-mode -1)
#+END_SRC

*** Backup files

No Backup Files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC

*** Symlinks

Always Follow Symlinks, no questions asked.

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks nil)
#+END_SRC

*** Clipboard

Copy to clipboard.

#+BEGIN_SRC emacs-lisp
(setq x-select-enable-clipboard 't)
#+END_SRC

*** Auto-save

Auto-Save in /tmp

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+END_SRC

*** Evil

I am evil.

#+BEGIN_SRC emacs-lisp
(require 'evil-org)
(require 'evil-ediff)
(require 'evil)
(evil-mode t)
#+END_SRC

Evil God State

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal global-map "," 'evil-execute-in-god-state)
(evil-define-key 'god global-map [escape] 'evil-god-state-bail)
#+END_SRC

C-g to escape.

#+BEGIN_SRC emacs-lisp
(defun my-esc (prompt)
  "Functionality for escaping generally"
  (cond
   ((or (evil-insert-state-p)
        (evil-normal-state-p)
        (evil-replace-state-p)
        (evil-visual-state-p)
        (evil-god-state-bail))
    [escape])
   (t (kbd "C-g"))))
(define-key key-translation-map (kbd "C-g") 'my-esc)
(define-key evil-operator-state-map (kbd "C-g") 'keyboard-quit)
(set-quit-char "C-g")
#+END_SRC



*** Smex

A better M-x.

#+BEGIN_SRC emacs-lisp
(require 'smex)
(smex-initialize)
#+END_SRC

*** Fixme-mode

Highlight `FIXME`, `BUG` and `TODO`.
    
#+BEGIN_SRC emacs-lisp
(fixme-mode t)
#+END_SRC
    
*** Spell Checking

For normal online spell checking I use hunspell.

#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "hunspell")
(setq ispell-local-dictionary "de_CH")
(setq ispell-nondefault-dictionary "en_GB")
(setq ispell-local-dictionary-alist '(("en_GB"
                                       "[[:alpha:]]"
                                       "[^[:alpha:]]"
                                       "[']"
                                       nil nil nil
                                       utf-8)
                                      ("de_CH"
                                       "[[:alpha:]]"
                                       "[^[:alpha:]]"
                                       "[']"
                                       nil nil nil
                                       utf-8)))

(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
  (add-hook hook (lambda () (flyspell-mode -1))))

(require 'ispell)

(defun flyspell-check-next-highlighted-word ()
   "Custom function to spell check next highlighted word"
  (interactive)
  (flyspell-goto-next-error)
  (ispell-word))
#+END_SRC

Change language

#+BEGIN_SRC emacs-lisp
(defun spell-checker-change-language ()
  (interactive)
  (cl-rotatef ispell-local-dictionary
              ispell-nondefault-dictionary)
  (message (concat "Switched language to: " ispell-local-dictionary)))
#+END_SRC

*** Emojify

Everybody loves emojis.

#+BEGIN_SRC emacs-lisp
(global-emojify-mode)
#+END_SRC

*** Drag stuff

#+BEGIN_SRC emacs-lisp
(require 'drag-stuff)
(drag-stuff-global-mode 1)
#+END_SRC

*** Org Mode

My org directory.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/org"))
#+END_SRC

A beatiful calendar (with some serous flaws with reoccuring events).

#+BEGIN_SRC emacs-lisp
(require 'calfw)
(require 'calfw-org)
;;(setq cfw:org-agenda-schedule-args '(:timestamp))
;;(setq cfw:org-overwrite-default-keybinding t)
#+END_SRC

*** Line numbers

#+BEGIN_SRC emacs-lisp
(global-linum-mode t)
#+END_SRC

*** Sudo files

I want to be asked if the file should be opened by root if it is not writable (this includes nonexistent files in write-protected folders).

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook 'find-file-sudo)
(defun find-file-sudo ()
  (when (and (not (file-writable-p buffer-file-name))
             (y-or-n-p "open file as root?"))
    (find-alternate-file (concat "/sudo:root@localhost:"
                                 buffer-file-name))
    (message "file opened as root")))
#+END_SRC

*** Elfeed

Set it all up.

#+BEGIN_SRC emacs-lisp
(require 'elfeed)
(require 'elfeed-goodies)
(require 'elfeed-org)
(elfeed-goodies/setup)
(elfeed-org)
(setq rmh-elfeed-org-files (list "~/git/config/emacs/elfeed.org"))
#+END_SRC

My most used filters have shortcuts.

#+BEGIN_SRC emacs-lisp
(defun elfeed-select-filter ()
  (interactive)
  (let ((x (read-string (concat "[ia] it-all  "
                                "[nz] nzz.ch  "
                                "[is] it-selcted  "
                                ":  "))))
    (cond ((string= x "ia")
           (elfeed-search-set-filter "@6-months-ago +it"))
          ((string= x "20")
           (elfeed-search-set-filter "@6-months-ago +20min"))
          ((string= x "nzz")
           (elfeed-search-set-filter "@6-months-ago +nzz"))
          ((string= x "is")
           (elfeed-search-set-filter "@6-months-ago +it -zdnet -hn")))))
#+END_SRC

Quickly toggle the +unread filter.

#+BEGIN_SRC emacs-lisp
(defun elfeed-toggle-filter-unread ()
  (interactive)
  (if (string-match ".*+unread.*" elfeed-search-filter)
    (elfeed-search-set-filter (replace-regexp-in-string "+unread" ""
                                                       elfeed-search-filter))
      (elfeed-search-set-filter (concat "+unread "
                                        elfeed-search-filter)))
  (elfeed-search-set-filter (replace-regexp-in-string "  " " " elfeed-search-filter)))

#+END_SRC

Clear the filter

#+BEGIN_SRC emacs-lisp
(defun elfeed-reset-filter ()
  (interactive)
  (elfeed-search-set-filter "@6-months-ago "))
#+END_SRC

Last but not least my elfeed keybindings.

#+BEGIN_SRC emacs-lisp
(add-hook 'elfeed-search-mode-hook
          (lambda ()
            (define-key evil-normal-state-local-map
              (kbd "c") 'elfeed-reset-filter)
            (define-key evil-normal-state-local-map
              (kbd "r") 'elfeed-toggle-filter-unread)
            (define-key evil-normal-state-local-map
              (kbd ";") 'elfeed-select-filter)
            (define-key evil-normal-state-local-map
              (kbd "F") 'elfeed-search-live-filter)
            (define-key evil-normal-state-local-map
              (kbd "!") 'elfeed-search-untag-all-unread)
            (define-key evil-normal-state-local-map
              (kbd "u") 'elfeed-search-tag-all-unread)
            (define-key evil-normal-state-local-map
              (kbd "O") 'elfeed-search-browse-url)
            (define-key evil-normal-state-local-map
              (kbd "U") 'elfeed-update)
            (define-key evil-normal-state-local-map
              (kbd "RET") 'elfeed-goodies/split-search-show-entry)))
(add-hook 'elfeed-show-mode-hook
          (lambda ()
            (define-key evil-normal-state-local-map
              (kbd "n") 'elfeed-goodies/split-show-next)
            (define-key evil-normal-state-local-map
              (kbd "p") 'elfeed-goodies/split-show-prev)))
#+END_SRC

*** Projectile

#+BEGIN_SRC emacs-lisp
(projectile-global-mode)
(setq projectile-completion-system 'grizzl) ;; to compare with default (ido)
(setq projectile-enable-caching t)
(setq projectile-require-project-root nil) ;; use projectile everywhere
#+END_SRC

*** Ido

#+BEGIN_SRC emacs-lisp
(require 'ido)
(ido-mode 1)
(ido-everywhere 1)
(setq ido-enable-flex-matching t)
#+END_SRC

*** Helm

#+BEGIN_SRC emacs-lisp
(setq helm-buffers-fuzzy-matching 1)
(helm-projectile-on)
#+END_SRC

*** Faces

#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(show-paren-match ((((class color) (background dark)) (:background "firebrick")))))
#+END_SRC

*** Themes

Toggle dark and light theme.

#+BEGIN_SRC emacs-lisp
(defun toggle-dark-light-theme ()
  (interactive)
  (let ((is-light (cl-find 'whiteboard custom-enabled-themes)))
    (dolist (theme custom-enabled-themes)
      (disable-theme theme))
    (load-theme (if is-light 'wombat  'whiteboard))))
(load-theme 'wombat t)
#+END_SRC

*** Font

#+BEGIN_SRC emacs-lisp
(setq default-frame-alist
      '((font . "DejaVu Sans Mono-12")))
#+END_SRC

*** Mail

Load it.

#+BEGIN_SRC emacs-lisp
(require 'mu4e)
(require 'mu4e-maildirs-extension)
(require 'mu4e-contrib)
(require 'evil-mu4e)
(require 'smtpmail)
#+END_SRC

My contexts.

#+BEGIN_SRC emacs-lisp
(setq mu4e-contexts nil)
(load-file "~/git/config/emacs/private.el")
(setq mu4e-context-policy 'pick-first)
(setq mu4e-compose-context-policy 'ask-if-none)
#+END_SRC

Sending messages.

#+BEGIN_SRC emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it)
(setq starttls-use-gnutls t)
(setq smtpmail-debug-info t)
#+END_SRC

Activate Alert

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
#+END_SRC

Show me the addresses, not only names.

#+BEGIN_SRC emacs-lisp
(setq mu4e-view-show-addresses t)
#+END_SRC

Show text, not html.

#+BEGIN_SRC emacs-lisp
(setq mu4e-html2text-command 'mu4e-shr2text)
#+END_SRC

No automatic line breaks.

#+BEGIN_SRC emacs-lisp
(defun no-auto-fill ()
  "Turn off auto-fill-mode."
  (auto-fill-mode -1))
(add-hook 'mu4e-compose-mode-hook #'no-auto-fill)
#+END_SRC

View mail in browser (with "aV").

#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-view-actions
             '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+END_SRC

Skip duplicates

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-skip-duplicates t)
#+END_SRC

Some self explanatory settings.

#+BEGIN_SRC emacs-lisp
(setq mu4e-maildir "~/.mail")
(setq mu4e-get-mail-command "offlineimap -o")
(setq message-kill-buffer-on-exit t)
#+END_SRC


Check for forgotten attachments (TODO: Refactor)

#+BEGIN_SRC emacs-lisp
(add-hook 'message-send-hook 'check-forgotten-attachment)
(setq suspicious-regex-list '("^.*attach.*$"
                              "^.*angehäng.*$"
                              "^.*angehaeng.*$"
                              "^.*anhang.*$"))
(setq attachment-regex-list '("^.*<#part.*$"))

(defun check-forgotten-attachment ()
  "Returns t if the mail doesn't containany suspicious"
  "words or if the user approved, else nil"
  (interactive)
  (let ((line-list (read-lines (buffer-file-name))))
    (if (> (regex-test line-list suspicious-regex-list) 0)
        (unless (or (> (regex-test line-list attachment-regex-list) 0)
                    (yes-or-no-p "Did you add all your attachments?"))
          (error "add the damn attachment(s)")))))

(defun regex-test (file-lines regex-list)
  "Returns the number of regex-matches in a list of strings"
  (interactive)
  (let ((matches 0))
    (dolist (line file-lines)
        (unless (string= ">" (substring line 0 1)) ; no check if line starts with ">"
            (dolist (regex regex-list)
                (if (string-match regex line)
                    (incf matches)))))
    (+ matches 0))) ; bump, there must be a better way to make sure the right value is returned

(defun read-lines (filePath)
  "Return a list of lines of a file at filePath."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string (buffer-string) "\n" t)))
#+END_SRC

*** Markdown Mode

#+BEGIN_SRC emacs-lisp
(require 'markdown-mode)
(setq markdown-command "pandoc")
#+END_SRC

*** Auto complete

#+BEGIN_SRC emacs-lisp
(ac-config-default)
#+END_SRC

** Programming

*** Latex

To make evince go to the updated page when using auctex to compile.

#+BEGIN_SRC emacs-lisp
(setq TeX-view-program-list '(("Evince" "evince --page-index=%(outpage) %o")))
(setq TeX-view-program-selection '((output-pdf "Evince")))
#+END_SRC

Use evince and firefox

#+BEGIN_SRC emacs-lisp
(setq TeX-output-view-style
      (quote
       (("^pdf$" "." "evince -f %o")
        ("^html?$" "." "firefox %o"))))
#+END_SRC


I put a `make.sh` in the root of latex documents along with the main tex file `main.tex` and of course the `.gitignore`.

#+BEGIN_SRC emacs-lisp
(defun my-latex-compile-quick ()
  "runs make.sh -q -s (..) in the latex root"
  (interactive)
  (let* ((main-folder (get-latex-main-folder
                       (file-name-directory buffer-file-name)))
         (command (concat "sh " main-folder "make.sh " "-q "
                          "-s " (number-to-string
                                 (line-number-at-pos)) ":"
                          (buffer-file-name))))
    (start-process "my-latex" "latex-make"
                   (concat main-folder "make.sh") "-q"
                   "-s" (concat (number-to-string
                                 (line-number-at-pos)) ":"
                                 (buffer-file-name)))))

(defun my-latex-compile-full ()
  "runs make.sh -f -s (..) in the latex root"
  (interactive)
  (let* ((main-folder (get-latex-main-folder
                       (file-name-directory buffer-file-name)))
         (command (concat "sh " main-folder "make.sh " "-f "
                          "-s " (number-to-string
                                 (line-number-at-pos)) ":"
                          (buffer-file-name))))
    (start-process "my-latex" "latex-make"
                   (concat main-folder "make.sh") "-f"
                   "-s" (concat (number-to-string
                                 (line-number-at-pos)) ":"
                                 (buffer-file-name)))))

(defun update-evince ()
  "updates evince"
  (interactive)
  (let* ((main-folder (get-latex-main-folder
                       (file-name-directory buffer-file-name)))
         (command (concat "sh " main-folder "make.sh " "-f "
                          "-s " (number-to-string
                                 (line-number-at-pos)) ":"
                          (buffer-file-name))))
    (start-process "my-latex" "latex-make"
                   (concat main-folder "make.sh") "-f"
                   "-s" (concat (number-to-string
                                 (line-number-at-pos)) ":"
                                 (buffer-file-name)))))

(defun my-latex-clean ()
  "runs make.sh -c in the latex root"
  (interactive)
  (let ((main-folder (get-latex-main-folder
                      (file-name-directory buffer-file-name))))
    (shell-command-to-string (concat "sh " main-folder
                                     "make.sh clean"))))

(defun get-latex-main-folder (path)
  "recursively gets the root folder of the latex project"
  (interactive)
  (if (not (string= path "/"))
      (if (is-latex-root path)
          path
        (get-latex-main-folder (folder-up path)))))

(defun folder-up (path)
  "removes last folder of path"
  (file-name-directory (directory-file-name path)))

(defun is-latex-root (path)
  "returns t if the path is the root folder of the latex project"
  (interactive)
  (and (file-exists-p (concat path ".gitignore"))
       (file-exists-p (concat path "main.tex"))
       (file-exists-p (concat path "make.sh"))))

#+END_SRC
*** 80 columns indicator.

#+BEGIN_SRC emacs-lisp
(require 'fill-column-indicator)
(setq fci-rule-width 1)
(setq fci-rule-color "red")
#+END_SRC

*** Matching Brackets
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
(setq show-paren-style 'mixed)
(require 'rainbow-delimiters)
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC
*** Python

#+BEGIN_SRC emacs-lisp
(elpy-enable)
#+END_SRC

Use jupyter/ipython if present

#+BEGIN_SRC emacs-lisp
;;(when (executable-find "ipython3")
;;  (setq python-shell-interpreter "ipython3")
;;  (setq python-shell-interpreter-args "--simple-prompt --pprint"))
#+END_SRC

Auto complete with jedi
#+BEGIN_SRC emacs-lisp
;;(add-hook 'python-mode-hook 'jedi:setup)
;;(setq jedi:complete-on-dot t)
#+END_SRC

*** Indents

Set tab width to 2 for all buffers

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(setq js-indent-level 2)
(setq python-indent 2)
(setq css-indent-offset 2)
(add-hook 'sh-mode-hook
          (lambda ()
            (setq sh-basic-offset 2
                  sh-indentation 2)))

(setq web-mode-markup-indent-offset 2)
#+END_SRC

Use 2 spaces instead of a tab.

*** Whitespaces

To see whitespaces and indentation

#+BEGIN_SRC emacs-lisp
(require 'whitespace)
#+END_SRC

** Keybindings
*** Evil mode keybindings

Visual lines, not real lines.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
#+END_SRC

Evil shortcut.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
(evil-ex-define-cmd "ww" 'sudo-save)
#+END_SRC

*** Mu4e keybindings

#+BEGIN_SRC emacs-lisp
(define-key mu4e-main-mode-map (kbd "U") 'mu4e-update-index)
(add-hook 'mu4e-view-mode-hook
  (lambda()
    ;; try to emulate some of the eww key-bindings
    (local-set-key (kbd "<tab>") 'shr-next-link)
    (local-set-key (kbd "i") 'mu4e-view-toggle-html)
    (local-set-key (kbd "h") 'evil-backward-char)
    (local-set-key (kbd "F") 'mu4e-compose-forward) ; why no working ???
    (local-set-key (kbd "<backtab>") 'shr-previous-link)))

#+END_SRC

*** Global

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

*** Minor Global

#+BEGIN_SRC emacs-lisp
(defvar my-keys-minor-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "M-x")      'smex)
    (define-key map (kbd "C-j")      'drag-stuff-down)
    (define-key map (kbd "C-k")      'drag-stuff-up)
    (define-key map (kbd "C-c -")    'comment-region)
    (define-key map (kbd "C-c ö")    'uncomment-region)
    (define-key map (kbd "C-c d")    'fci-mode)
    (define-key map (kbd "C-c m")    'mu4e)
    (define-key map (kbd "C-c g")    'magit-status)
    (define-key map (kbd "C-c a")    'org-agenda)
    (define-key map (kbd "C-c n")    'elfeed)
    (define-key map (kbd "C-x C-b")  'helm-mini)
    (define-key map (kbd "C-x C-a")  'cfw:open-org-calendar)
    (define-key map (kbd "C-c C-p")  'helm-projectile-find-file)
    (define-key map (kbd "C-c C-w")  'toggle-truncate-lines)
    (define-key map (kbd "<f2>")     'spell-checker-change-language)
    (define-key map (kbd "C-S-<f9>") 'flyspell-buffer)
    (define-key map (kbd "<f5>")     'toggle-dark-light-theme)
    (define-key map (kbd "<f9>")     'ispell-word)
    (define-key map (kbd "C-<f9>")   'flyspell-check-next-highlighted-word)
    (define-key map (kbd "M-<f9>")   'flyspell-check-previous-highlighted-word)
    map)
  "my-keys-minor-mode keymap.")

(define-minor-mode my-global-keys
  :init-value t
  :keymap my-keys-minor-mode-map
  :lighter " my-keys")

(my-global-keys 1)
#+END_SRC

* Old unused stuff
** gnome keyring
#+BEGIN_SRC emacs-lisp
;; (defun get_keyring_password (user)
;;   (interactive)
;;   (let  ((x (shell-command-to-string
;;              (concat "secret-tool lookup user " user))))
;;     (format "%s" x)))
;; ;; Example call
;; ;; (defun test ()
;; ;;   (interactive)
;; ;;   (let ((x (get_keyring_password "asdf@gmail.com")))
;; ;;     (message "%s" x)))
#+END_SRC
   
** Neotree

I sometimes use neotree. not anymore

#+BEGIN_SRC emacs-lisp
;; (require 'neotree)
;; (add-hook 'neotree-mode-hook
;;           (lambda ()
;;             (define-key evil-normal-state-local-map
;;               (kbd "H") 'neotree-hidden-file-toggle)
;;             (define-key evil-normal-state-local-map
;;               (kbd "TAB") 'neotree-enter)
;;             (define-key evil-normal-state-local-map
;;               (kbd "SPC") 'neotree-enter)
;;             (define-key evil-normal-state-local-map
;;               (kbd "q") 'neotree-hide)
;;             (define-key evil-normal-state-local-map
;;               (kbd "RET") 'neotree-enter)))

#+END_SRC
